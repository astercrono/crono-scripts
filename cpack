#!/usr/bin/env bash

source "$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )/lib/configure.sh"

__CPACK_PATH="$(basename $0)"
__CPACK_CMDS=("extract" "compress" "help")
__CPACK_TYPES=("7z" "zip" "gzip" "bzip" "tar" "tgz" "xz" "wim" "rar")

#TODO: Add support for: RAR and ISO
declare -A __CPACK_CMD_DEF=(
    ["7z_extract"]="7z;_;7z x -y FILE"
    ["7z_compress"]="7z;_;7z a -y OUT.7z FILE"
    ["zip_extract"]="7z;_;7z x -tzip -y FILE"
    ["zip_compress"]="7z;_;7z a -tzip -y OUT.zip FILE"
    ["bzip_extract"]="bzip2;_;7z x -tbzip2 -y FILE"
    ["bzip_compress"]="bzip2;_;7z a -tbzip2 -y OUT.bz2 FILE"
    ["gzip_extract"]="gzip;_;7z x -tgzip -y FILE"
    ["gzip_compress"]="gzip;_;7z a -tgzip -y OUT.gz FILE"
    ["tar_extract"]="tar;_;7z x -ttar -y FILE"
    ["tar_compress"]="tar;_;7z a -ttar -y OUT.tar FILE"
    ["tgz_extract"]="tar;_;tar zxf FILE"
    ["tgz_compress"]="tar;7z;tar cf - FILE | 7z a -si OUT.tar.gz"
    ["xz_extract"]="7z;_;7z x -txz -y FILE"
    ["xz_compress"]="7z;_;7z a -txz -y OUT.xy FILE"
    ["wim_extract"]="7z;_;7z x -twim -y FILE"
    ["wim_compress"]="7z;_;7z a -twim -y OUT.wim FILE"
    ["rar_extract"]="unrar;_;unrar x -y FILE"
    ["rar_compress"]="rar;_;rar a -y OUT.rar FILE"
)

__cpack_usage() {
    fancy_print -n -s bold -c cyan "Usage: "
    fancy_print -n -s bold "$__CPACK_PATH "
    fancy_print -n -s underline "COMMAND" 
    echo -n " [options] "
    fancy_print -s underline "TARGET(S)"

    echo ""

    fancy_print -s bold -c green "Options: "
    echo -n "    -t "
    fancy_print -s underline "TYPE"
    echo "        Specify compression type"
    echo "    -d " 
    echo -n "        Treat " && fancy_print -n -s underline "TARGET" && echo " as a directory."
    echo "        Use all applicable files within the directory."
    echo "    -h "
    echo "        Print this help message"

    echo ""

    fancy_print -s bold -c green "Commands: "
    for c in "${__CPACK_CMDS[@]}"; do
        echo "    $c"
    done

    echo ""

    fancy_print -s bold -c green "Types: "
    for c in "${__CPACK_TYPES[@]}"; do
        echo "    $c"
    done
}

__cpack_valid_cmd() {
    local arg="$1"
    for c in "${__CPACK_CMDS[@]}"; do
        [[ "$c" == "$arg" ]] && return 0
    done
    return 1
}

__cpack_valid_type() {
    local arg="$1"
    for c in "${__CPACK_TYPES[@]}"; do
        [[ "$c" == "$arg" ]] && return 0
    done
    return 1
}

# TODO: Support -t flag for "test mode"
__cpack_run() {
    local space_encode="$%$"
    local cmd="$1"
    local pack_type=""
    local output_name=""
    
    if ! __cpack_valid_cmd "$cmd"; then
        fancy_print -s bold -c red "Invalid Command"
        __cpack_usage
        return 1
    elif [[ "$cmd" == "help" ]]; then
        __cpack_usage
        return 0
    fi

    shift

    # Read Options
    local OPTIND t o
    while getopts "t:o:" opt; do
        case "$opt" in
            t)
                pack_type="$OPTARG"
                ;;
            o)
                output_name="$OPTARG"
                ;;           
       esac 
    done
    shift $(($OPTIND - 1))

    # Pack Check
    if [[ "$pack_type" == "" ]]; then
        fancy_print -s bold -c red "Missing Pack Type"
        __cpack_usage
        return 1
    elif ! __cpack_valid_type "$pack_type"; then
        fancy_print -s bold -c red "Invalid Pack Type"
        __cpack_usage
        return 1
    fi

    # Target Cleaning
    local targets=()
    local clean_path=""
    OIFS="$IFS"
    IFS=$(echo -en "\n\b")
    for p in $@; do
        clean_path=$(echo "$p" | sed "s| |$space_encode|g")
        targets+=("$clean_path")
    done
    IFS="$OIFS"

    if [[ "${#targets[@]}" == "0" ]]; then
        fancy_print -s bold -c red "Missing Target(s)"
        __cpack_usage
        return 1
    fi

    # Opt Check
    # -o is not compatible with extract
    if [[ "$cmd" == "extract" && "$output_name" != "" ]]; then
        fancy_print -s bold -c red "Invalid argument -o for extract"
        return 1
    fi
    # Default output name to first file name
    if [[ "$output_name" == "" ]]; then
        output_name="${targets[0]}"
        output_name="${output_name//$space_encode/\ }"
    fi

    # Select file command
    local cmd_def_key="${pack_type}_$cmd"
    local cmd_def="${__CPACK_CMD_DEF[$cmd_def_key]}"
    local def_split=(${cmd_def//;/ })
    local def_cmd_exe1="${def_split[0]}"
    local def_cmd_exe2="${def_split[1]}"
    local def_cmd="${def_split[@]:2}"
    def_cmd="${def_cmd//OUT/$output_name}"

    # Command Checks
    if ! command -v "$def_cmd_exe1" &> /dev/null; then
        fancy_print -n -s bold -c red "Missing Program: "
        echo "$def_cmd_exe1"
        return 1
    fi
    if [[ "$def_cmd_exe2" != "_" ]] && ! command -v "$def_cmd_exe2" &> /dev/null; then
        fancy_print -n -s bold -c red "Missing Program: "
        echo "$def_cmd_exe2"
        return 1
    fi

    # Let's get to work
    local on_first=true
    local file_type="file"
    local start_time="$(date +"%D %I:%M %p")"
    local start_secs="$(date +%S)"
    local total_acted="0"

    fancy_print -s bold -c cyan "Begin @ $start_time"
    echo ""

    for p in "${targets[@]}"; do
        ogpath="${p//$space_encode/\ }"

        if [ ! -d "$ogpath" ] && [ ! -f "$ogpath" ]; then
            fancy_print -n -s bold -c yellow "Invalid Path: " && echo "$p"
            continue
        fi

        [ -d "$ogpath" ] && file_type="dir"

        fancy_print -n -s bold "[$pack_type] "
        fancy_print -n -s bold -c blue "${cmd^}ing"
        fancy_print -n -s bold " ($file_type) "
        echo "$ogpath"

        cmd_final=${def_cmd//FILE/$p}
        cmd_final=${cmd_final//$space_encode/\\ }

        # We have to do the first evaluation in the foreground to ensure that the package is first created.
        # After the package is created, we can subjob in bg to append
        [ $on_first ] && eval "${cmd_final[@]}" &>/dev/null && on_first=false
        [ ! $on_first ] && eval "${cmd_final[@]}" &>/dev/null &

        total_acted=$((total_acted+1))
    done

    wait

    local end_time="$(date +"%D %I:%M %p")"
    local end_secs="$(date +%S)"

    echo ""
    fancy_print -s bold "Files Processed: $total_acted"

    local dur_secs=$(($end_secs - $start_secs))

    if [ "$dur_secs" -gt 60 ]; then
        local dur_mins=$(bc <<< "scale=2; ($dur_secs)/60")
        fancy_print -s bold "Duration: ${dur_mins}m"
    else 
        fancy_print -s bold "Duration: ${dur_secs}s"
    fi

    echo ""
    fancy_print -s bold -c green "Done @ $end_time"

    return 0
}

if ! command -v "bc" &> /dev/null; then
    fancy_print -n -s bold -c red "Missing Program: "
    echo "bc"
    exit 1
fi

__cpack_run "$@"